# Test the local_minima function in landscapes.py

import numpy as np
import scipy.signal as signal

def local_minima(func_vals,func_shape): # Static or class method?
        
        """
        Finds the list of local minima in the desired array
        signal.argrelmax finds maxima, so we find the maxima of -1*array
        signal.argrelmax returns any kind of minima (eg along any of the directions), not necessarily a minima in all directions
        we thus further analyse the result to obtain those points that are true local minima in all directions
        note that this method ignores points at the extremes of a given dimension
        
        TODO: systematically ensure this method is correct by constructing landscapes with known local minima & make sure it returns right result
        """

         
        mins = signal.argrelmax(-1*func_vals)
        mins = [[mins[0][i],mins[1][i]] for i in range(len(mins[0]))]
        
        local_mins = []
        for i in mins: 
            
            val_here = func_vals[tuple(i)] # Function value at coordinate i
            
            # Get indices of neighbouring points, checking if the point on the boundary of the coordinate system (ignore if so)
            edge_pts = [j for j in range(len(i)) if i[j] == func_shape[j]-1 or i[j] == 0]
            if edge_pts: 
                continue
            else:
                nbours = np.array([i]*4) + np.array([[-1,0], [0,-1], [1, 0], [0,1]]) # coordinates of neighbouring points (NEED TO EXTEND TO ARBITRARY DIMS)
            
            val_nbours = [func_vals[tuple(j)] for j in nbours] # Function values at neighbouring points

            if all(val_nbours > val_here): # "Greater than" because argrelmax finds peaks
                local_mins.append(i)

def generate_rand_min_matr(n):
    
    matr = np.random.rand(n,n)
    n_min = np.random.randint(low=1,high=15)
    print(n_min)
    
    upper = n - 2
    coords = np.random.randint(low=1,high=n-2,size=(n_min,2))
    
    for i in range(n_min):
    
        matr[tuple(coords[i])] = -0.5
        
    return matr, coords
